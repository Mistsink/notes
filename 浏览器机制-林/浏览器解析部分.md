# 浅析 浏览器解析机制

------

## 背景

### 主流浏览器

> 目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 和 Opera。

![](.\image\五大主流浏览器.jpg)

## 浏览器的主要功能

浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。

浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。 
多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。 

　　浏览器的用户界面有很多彼此相同的元素，其中包括：

- 用来输入 URI 的地址栏

- 前进和后退按钮

- 书签设置选项

- 用于刷新和停止加载当前文档的刷新和停止按钮

- 用于返回主页的主页按钮

  ![](D:\前端笔记\浏览器机制\image\浏览器功能.png)

　　奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5  也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如  Firefox 的下载管理器。

------



## 浏览器的高层结构

浏览器的主要组件为 ：

1. **用户界面** - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
2. **浏览器引擎** - 在用户界面和呈现引擎之间传送指令。
3. **呈现引擎** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
4. **网络** - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。
5. **用户界面后端** - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
6. **JavaScript 解释器**。用于解析和执行 JavaScript 代码。
7. **数据存储**。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

![](D:\前端笔记\浏览器机制\image\浏览器主要组件.png)



## 浏览器引擎（内核）

浏览器引擎分为两个部分：渲染引擎（lauout enginner 或者 Rendering Engine ) 和 JS引擎。

- 渲染引擎

渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。

- JS引擎

JS引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。主要为V8引擎

![](.\image\V8引擎.png)

（雾）、、、

## 呈现（渲染）引擎

​       呈现引擎的作用嘛...当然就是“呈现”了，也就是在浏览器的屏幕上显示请求的内容。

　　默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其它类型的内容；例如，使用  PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。

### 主流程

​       呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。

　　然后进行如下所示的基本流程：

![](.\image\渲染引擎主流程.png)

- 解析HTML来构建DOM树
- 建立呈现树
- 根据呈现树布局
- 绘制

呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 [DOM](https://www.cnblogs.com/lhb25/p/how-browsers-work.html#DOM) 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：[呈现树](https://www.cnblogs.com/lhb25/p/how-browsers-work.html#Render_tree_construction)。

　　呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。

　　呈现树构建完毕之后，进入“[布局](https://www.cnblogs.com/lhb25/p/how-browsers-work.html#layout)”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是[绘制](https://www.cnblogs.com/lhb25/p/how-browsers-work.html#Painting) - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。

　　需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。

两种主流呈现引擎--Webkit&Gecko的主流程

![](.\image\webkit主流程.png)

<center>Webkit 主流程</center>

![](.\image\Gecko主流程.jpg)

<center>Mozilla 的 Gecko 呈现引擎主流程</center>

　Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。Webkit  使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，Webkit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接  DOM 节点和可视化信息从而创建呈现树的过程，Webkit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与  DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。

### HTML解析++

解析器和词法分析器的组合

　　解析的过程可以分成两个子过程：词法分析和语法分析。

　　词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。

　　语法分析是应用语言的语法规则的过程。（）

　　解析器通常将解析工作分给以下两个组件来处理：**词法分析器**（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而**解析器**负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。

![](.\image\从源文档到解析树.png)

解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。

　　如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。

#### 翻译

　　很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。

![](.\image\编译流程.png)

#### DOM

　　解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。 
　　解析树的根节点是“[Document](http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document)”对象。DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：

```html
<html>
  <body>
    <p>
      Hello World
    </p>
    <div> <img src="example.png"/></div>
  </body>
</html>
```

可翻译成如下的 DOM 树：

![](.\image\解析成的DOM树.png)

和 HTML 一样，DOM 也是由 W3C 组织指定的。请参见[www.w3.org/DOM/DOMTR](http://www.w3.org/DOM/DOMTR)。这是关于文档操作的通用规范。其中一个特定模块描述针对 HTML 的元素。HTML 的定义可以在这里找到：[www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html](http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html)。

　　我所说的树包含 DOM 节点，指的是树是由实现了某个 DOM 接口的元素构成的。浏览器所用的具体实现也会具有一些其他属性，供浏览器在内部使用。

#### 解析算法

　　我们在之前章节已经说过，HTML 无法用常规的自上而下或自下而上的解析器进行解析。原因在于：

1. 语言的宽容本质。
2. 浏览器历来对一些常见的无效 HTML 用法采取包容态度。
3. 解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 `document.write`，就会添加额外的标记，这样解析过程实际上就更改了输入内容。

　　由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。[HTML5 规范详细地描述了解析算法](http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html)。此算法由两个阶段组成：标记化和树构建。

　　标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。

![](D:\前端笔记\浏览器机制\image\html解析流程.png)

#### 标记化算法

　　该算法的输出结果是 HTML  标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。

　　基本示例 - 将下面的 HTML 代码标记化：

```html
<html>
  <body>
    Hello world
  </body>
</html>
```

初始状态是数据状态。遇到字符 `<` 时，状态更改为**“标记打开状态”**。接收一个 `a-z`字符会创建“起始标记”，状态更改为**“标记名称状态”**。这个状态会一直保持到接收`>` 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 `html` 标记。

　　遇到 `>` 标记时，会发送当前的标记，状态改回**“数据状态”**。`<body>` 标记也会进行同样的处理。目前 `html` 和 `body` 标记均已发出。现在我们回到**“数据状态”**。接收到 `Hello world` 中的 `H` 字符时，将创建并发送字符标记，直到接收 `</body>` 中的`<`。我们将为 `Hello world` 中的每个字符都发送一个字符标记。

　　现在我们回到**“标记打开状态”**。接收下一个输入字符 `/` 时，会创建 `end tag token` 并改为**“标记名称状态”**。我们会再次保持这个状态，直到接收 `>`。然后将发送新的标记，并回到**“数据状态”**。`</html>` 输入也会进行同样的处理。

![](D:\前端笔记\浏览器机制\image\对示例输入进行标记化.png)

#### 树构建算法

　　在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM  树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM  元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM  树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。

　　让我们来看看示例输入的树构建过程：

```html
<html>
  <body>
    Hello world
  </body>
</html>
```

​       树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是**“initial mode”**。接收 HTML 标记后转为**“before html”**模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。

　　然后状态将改为**“before head”**。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。

　　现在我们进入了**“in head”**模式，然后转入**“after head”**模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为**“body”**。++

　　现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。

　　接收 body 结束标记会触发**“after body”**模式。现在我们将接收 HTML 结束标记，然后进入**“after after body”**模式。接收到文件结束标记后，解析过程就此结束。

![](D:\前端笔记\浏览器机制\image\示例html的树构建.gif)

#### 解析结束后的操作

　　在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“deferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发。您可以[在 HTML5 规范中查看标记化和树构建的完整算法](http://www.w3.org/TR/html5/syntax.html#html-parser)

### CSS 解析

------

一旦 CSS 被浏览器下载，CSS 解析器就会被打开来处理它遇到的任何CSS。这可以是单个文档内的CSS、`<style>`标记内的CSS，也可以是 DOM 元素的`style`属性内嵌的 CSS。所 有CSS 都根据语法规范进行解析和标记。解析完成后，就会生成有一个包含所有选择器、属性和属性各自值的数据结构

例如，考虑以下 CSS:

```css
.fancy-button {
    background: green;
    border: solid red;
    font-size: 1em;
}
```

以上 CSS 片段将生成如下数据结构，以便在后续的过程中方便使用：

![](D:\前端笔记\浏览器机制\image\样式表.webp)

- 值得注意的一件事是，浏览器将 `background` 和 `border` 的简写还原成普通写法，也就是一个一个属性的声明，因为简单写主要方便开发人员的编写，但从这里开始，浏览器只处理普通写法。完解析成之后，浏览器引擎继续构建 DOM 树。



#### 计算

------

既然我们已经解析了现有内容中的所有样式，接着就是对它们进行样式计算了。我们尝试尽量对所有值减少到一个标准化的计算值。当离开计算阶段时，任何维度值都被缩减为三个可能的输出之一:`auto`、百分比或像素值。为了清晰起见，让我们看几个例子，看 web 开发人员写了什么，以及计算后的结果:

![](D:\前端笔记\浏览器机制\image\计算值.png)

- 现在我们已经计算了数据存储中的所有值，接下来就是处理级联了。

#### 级联

------

由于 CSS 来源有多种，所以浏览器需要一种方法来确定哪些样式应该应用于给定的元素。为此，浏览器使用一个名为 **特殊性(specificity)** 的公式，它计算选择器中使用的标记、类、id 和属性选择器的数值，以及 `!important`声明的数值。

通过内联 `style` 属性在元素上定义的样式被赋予一个等级，该等级优先于 `<style>` 块或外部样式表中的任何样式。如果 Web 开发人员使用 `!important` 某个值，则该值将胜过任何 CSS，无论其位置如何，除非还有 `!important` 内联。

同一级别的个数，数量多的优先级高，假设同样即比较下一级别的个数。至于各级别的优先级例如以下：

**!important > 内联 > ID > 类 > 标签 | 伪类 | 属性选择 > 伪对象 >  通配符 > 继承**

![](D:\前端笔记\浏览器机制\image\选择器特殊值.webp)

选择器的特殊性由选择器本身的组件确定，特殊性值表述为5个部分，如：

(1)、对于选择器中给定的各个 `!important` 属性值，加 1，0，0，0，0 。

(2)、对于选择器中给定的各个内联样式，加 0，1，0，0，0 。

(3)、对于选择器中给定的各个ID属性值，加 0，0，1，0，0 。

(4)、对于选择器中给定的各个类属性值、属性选择器或伪类，加 0，0，0，1，0 。

(5)、对于选择器中给定的各个元素和伪元素，加 0，0，0，0，1 。

> 为了说明这一点，让我们说明一些选择器及其计算后的权重数值:

![](D:\前端笔记\浏览器机制\image\特殊值计算.webp)

- 而当优先级与多个CSS声明中任意一个声明的优先级相等的时候，CSS 中最后的那个声明将会被应用到元素上。

在下面的示例中，div 将具有蓝色背景。

```css
div {
  background: red;
}
div {
  background: blue;
}
```

现在CSS将生成以下数据结构，在本文中，我们将继续在此基础上进行构建。

![](D:\前端笔记\浏览器机制\image\蓝色背景计算值.webp)

#### 来源

------

CSS也有来源，但它们的用途不同:

CSS信息可以从各种来源提供，这些来源可以是 用户(user) 和 作者(author) 及 用户代理/浏览器(user agent)，优先级如下：

##### **用户样式**

浏览器还允许用户设置网页的样式，例如，我们用IE浏览网站的时候，都可以通过浏览器查看菜单下的样式或者文字大小子菜单来设置网页实际的显示效果。

##### **作者样式**

网页创建者建立的样式表，一般会css文件出现或者是在页面头部里定义的style，也就是网站源代码的一部分。例如，大家看百度和谷歌的页面就不一样，这就是作者样式不一样的结果。

##### **用户代理/浏览器样式**

也就是浏览器自身设置用来显示网站的样式，不同的浏览器可能有不同的样式表，例如IE和Firefox的就不一样，所以大家分别使用这两种浏览器访问同一个网站的时候，看到实际效果可能就不同。

通常情况下，作者样式具有最高的重要性，其次是用户样式，最后才是浏览器样式，但是如果出现了 `!important` 标记的话，那么规则会被改变，通过 `!important` 可以提高某种样式的重要性，让它的优先级高于其他没有加该声明的所有样式。



#### 做级联

------

当浏览器拥有一个完整的数据结构，包含来自所有源的所有声明时，它将按照规范对它们进行排序。首先，它将按来源排序，然后按特性(specificity)排序，最后按文档顺序排序。

![](D:\前端笔记\浏览器机制\image\级联表.webp)

从上图可知，类名为 `.fancy-button`优先级最高（表中越上面优先级越高）。例如，从上表中，人会注意到用户的浏览器首选项设置优先 于Web 开发人员的设置样式。

#### 生成CSSOM树++

- 现在，浏览器找到与选择器匹配的所有 DOM 元素，并将得到的计算样式挂载到匹配的元素。

得到的结果即为CSSOM树

> 举个例子

假设css样式如下
```css
body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
```

解析成的样式表为 

| origin | Selector |  property   | value | specificity Score | Document Order |
| :----: | :------: | :---------: | :---: | :---------------: | :------------: |
| Author |   body   |  font-size  | 16px  |     0 0 0 0 1     |       0        |
| Author |    p     | font-weight | bold  |     0 0 0 0 1     |       1        |
| Author |   span   |    color    |  red  |     0 0 0 0 1     |       2        |
| Author |  p span  |   display   | none  |     0 0 0 1 1     |       3        |
| Author |   img    |    float    | right |     0 0 0 0 1     |       4        |

然后进行排序
| origin | Selector |  property   | value | specificity Score | Document Order |
| :----: | :------: | :---------: | :---: | :---------------: | :------------: |
| Author |  p span  |   display   | none  |     0 0 0 0 2     |       3        |
| Author |   body   |  font-size  | 16px  |     0 0 0 0 1     |       0        |
| Author |    p     | font-weight | bold  |     0 0 0 0 1     |       1        |
| Author |   span   |    color    |  red  |     0 0 0 0 1     |       2        |
| Author |   img    |    float    | right |     0 0 0 0 1     |       4        |


得到的CSSOM为

![](D:\前端笔记\浏览器机制\image\CSSOM.png)

#### 布局

现在我们已经应用了一个具有样式的 DOM 树，然后开始构建一个用于可视化目的的树了。这棵树出现在所有现代引擎中，被称为盒子树(box tree)。为了构造这棵树，我们遍历 DOM 树并创建零个或多个 CSS 盒子，每个盒子都有一个 `margin`、`border`、`padding` 和 `content` 。

在本节中，我们将讨论以下 CSS 布局概念:

- 格式化上下文（FC）：有许多类型的格式化上下文，其中大多数 Web 开发人员通过更改 `display` 元素的值来调用。一些最常见的格式化上下文是块（块格式化上下文或**BFC**），flex，grid，table-cells 和 inline。其他一些CSS也可以强制使用新的格式化上下文，例如 `position: absolute`，`float` 或使用 `multi-colum`。
- 包含块:这是用于解析样式的祖先块。
- 内联方向：这是文本布局的方向，由元素的书写模式决定。 在拉丁语言中，这是水平轴，在 CJK 语言中，这是垂直轴。
- 块方向：此行为与内联方向完全相同，但与内联轴垂直。因此，对于基于拉丁语的语言，这是垂直轴，而在CJK语言中，这是水平轴。

##### 解析 Auto

------

​        在计算阶段，维度值可以是三个值之一:auto、百分数或像素。布局的目的是在**Box Tree**中调整所有盒子的大小和位置，使它们为绘制做好准备。

下面示例可以更容易地理解**Box Tree**是如何构建的。为了便于理解，这里不显示单独的CSS框，只显示主盒(principal box)。让我们看看一个基本的 “Hello world” 布局使用以下代码:

```html
<body>
<p>Hello world</p>
<style>
    body {
        width: 50px;
    }
</style>
</body>
```

- 浏览器从 body 元素开始，生成它的主盒(principal box)，它的宽度为`50px`，默认高度为`auto`。

![](D:\前端笔记\浏览器机制\image\boxTree.webp)

- 现在移动到 `p` 标签并生成其主盒(principal box)，并且由于 `p` 标签默认有边距（margin），这将影响正文的高度，如下所示：

![](D:\前端笔记\浏览器机制\image\BoxTree_P.webp)

- 现在浏览器移动到 **“Hello world”** 文本，这是 DOM 中的文本节点。因此，我们在布局中生成一个 **行内盒(line box)** 。请注意，文本溢出了正文，我们将在下一步处理这个问题。

![](D:\前端笔记\浏览器机制\image\boxTree_L.webp)

- 因为加上“world”长度后实际长度比较设置大并且我们没有设置 `overflow` 属性，所以引擎会向其父级报告它在布局文本时停止的位置。

![](D:\前端笔记\浏览器机制\image\boxtree_LL.webp)

- 由于父级已收到其子级无法完成所有内容布局的指令，因此它会克隆包含所有样式的 **行内盒(line box)**，并传递该框的信息以完成布局。 

- 布局完成后，浏览器会返回 `box tree`，解析尚未解决的所有基于 `auto` 或基于百分比的值。 在图中，可以看到正文和段落现在包含所有 “Hello world”，因为它的 **height** 设置为 `auto`。

##### 处理浮动 float

------

现在让布局变得更复杂一点。我们将使用一个普通布局，其中有一个按钮，内容为 **“Share It”**，并将其浮动到一段文本的左侧。浮动本身被认为是**“shrink-to-fit”** 上下文。之所以将其称为“shrink-to-fit”，是因为如果尺寸是自动的，则该框将围绕其内容进行收缩。

浮动盒子是与这种布局类型匹配的盒子的一种类型，但是还有许多其他的盒子，例如绝对定位盒子(包括 `position: fixed`)和基于自动调整大小的表格单元格，如下代码：

```html
<article>
    <button>SHARE IT</button>
    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam pellentesq</p>
</article>
<style>
    article {
        min-width: 400px;
        max-width: 800px;
        background: rgb(191, 191, 191);
        padding: 5px;
    }

    button {
        float: left;
        background: rgb(210, 32, 79);
        padding: 3px 10px;
        border: 2px solid black;
        margin: 5px;
    }

    p {
        margin: 0;
    }
</style>
```

![](D:\前端笔记\浏览器机制\image\boxtree_float.webp)

- 该过程开始时遵循与“Hello world”示例相同的模式，因此我将跳到我们开始处理浮动按钮的位置。

![](D:\前端笔记\浏览器机制\image\boxTree_button_float.png)

由于浮动创建了一个新的块格式化上下文(BFC)，并且是一个 `shrink-to-fit` 上下文，因此浏览器执行一种称为内容度量的特定布局类型。

在这种模式下，它看起来与其他布局相同，但有一个重要的区别，即它是在无限空间中完成的。在此阶段，浏览器所做的就是以 BFC 的最大和最小宽度布局 BFC 树。

在本例中，它使用文本布局一个按钮，因此其最窄的大小(包括所有其他CSS框)将是最长单词的大小。在最宽的地方，它将是一行的所有文本，加上 CSS Box。注意:这里按钮的颜色不是文字的颜色。这只是为了说明问题。

![](D:\前端笔记\浏览器机制\image\boxtree_bfc.webp)

- 现在我们知道最小宽度是86px，最大宽度是115px，我们将此信息传递回父类的box，让它决定宽度并适当地放置按钮。在这个场景中，有足够的空间来适应浮动的最大大小，这就是按钮的布局方式。

![](D:\前端笔记\浏览器机制\image\boxtree_bfc_3.webp)

- 为了确保浏览器遵循标准，并且内容围绕浮动，浏览器更改了 **article** 的 BFC 的几何形状。这个几何图形被传递给段落，以便在段落布局期间使用。

![](D:\前端笔记\浏览器机制\image\boxtree_bfc_4.webp)

- 从这里开始，浏览器遵循与第一个示例相同的布局过程——但是它确保任何内联内容的内联和块的起始位置都位于浮动所占用的约束空间之外。

![](D:\前端笔记\浏览器机制\image\boxtree_bfc_5.webp)

- 当浏览器继续沿着树向下移动并克隆节点时，它将越过约束空间的块位置。这允许最后一行文本(以及它之前的一行)以内联方向开始于content box 的开头。然后浏览器返回到树中，根据需要解析 **auto** 和百分数。
  

绘画（Painting）

来回顾一下我们现在的情况，我们取出所有的 CSS 内容，对其进行解析，将其级联到DOM 树中，并完成布局。但是我们还没有对布图应用颜色、边框、阴影和类似的设计处理——处理这些过程被称为**绘画**。

绘画基本上是由CSS标准化的，简单地说，你可以按照以下顺序绘画:

- background;
- border;
- and content.

更多绘画的顺序可查看 [CSS 2.2 Appendix E](https://www.w3.org/TR/CSS22/zindex.html#painting-order)。

因此，如果我们从前面的“SHARE IT”按钮开始，并遵循这个过程，它绘制过程大致如下:

![](D:\前端笔记\浏览器机制\image\painting.png)

完成后，它将转换为位图，最终每个布局元素（甚至文本）都成为引擎中的图像。



##### 关于 Z-INDEX

------

现在，我们大多数的网站都不是由单一的元素组成的。此外，我们经常希望某些元素出现在其他元素之上。为了实现这一点，我们可以利用 `z-index` 的特性将一个元素叠加到另一个元素上。

这可能感觉就像我们在设计软件中使用图层一样，但是唯一存在的图层是在浏览器的合成器中。看起来好像我们在使用 `z-index` 创建新层，但实际上并不是这样，那么到底是怎么样呢?

我们要做的是创建一个新的堆栈上下文。创建一个新的堆叠上下文可以有效地改变你绘制元素的顺序。让我们来看一个例子:

```html
<body>
    <div id="one">
        Item 1
    </div>
    <div id="two">
        Item 2
    </div>
    <style>
    body {
        background: lightgray;
    }
    div {
        width: 300px;
        height: 300px;
        position: absolute;
        background: white;
        z-index: 2;
    }
    #two {
        background: green;
        z-index: 1;
    }
    </style>
</body>
```

- 如果没有使用 `z-index`，上面的文档将按照文档顺序绘制，这将把 **“Item 2”** 置于 **“Item 1”** 之上。但由于 `z-index` 的影响，绘画顺序发生了变化。让我们逐步完成每个阶段，类似于我们之前完成布局的方式。  

![](D:\前端笔记\浏览器机制\image\zindex.png)

浏览器以根框开头，我们在后台画画。

![](D:\前端笔记\浏览器机制\image\zindex3.png)

然后浏览器按照文档顺序遍历较低层次的堆栈上下文(在本例中是“Item 2”)，并开始按照上面的规则绘制该元素。

![](D:\前端笔记\浏览器机制\image\zindex4.png)

然后它遍历到下一个最高的堆栈上下文(在本例中是“Item 1”)，并按照 CSS 2.2中定义的顺序绘制它。

`z-index` 不影响颜色，只影响哪些元素对用户可见，因此也不影响哪些文本和颜色可见。

##### 创造互动的视觉

------

正如我们刚刚了解到的，我们使用了所有的样式和DOM，并生成了一个呈现给最终用户的图像。那么浏览器如何创建交互性的假象呢?嗯，我相信你现在已经学过了，所以让我们看一个例子，用我们的 “SHARE IT” 按钮作为类比:

```css
button {
    float: left;
    background: rgb(210, 32, 79);
    padding: 3px 10px;
    border: 2px solid black;
}
button:hover {
    background: teal;
    color: black;
}
```

- 我们在这里添加的是一个伪类，它告诉浏览器在用户悬停在按钮上时更改按钮的背景和文本颜色。这就引出了一个问题，浏览器如何处理这个问题?

- 浏览器不断跟踪各种输入，当这些输入正在移动时，它会经历称为**命中测试**的过程。 对于此示例，该过程如下所示：

![](D:\前端笔记\浏览器机制\image\am1.webp)

1. 用户将鼠标移到按钮上。
2. 浏览器触发鼠标已移动的事件，并进入命中测试算法，该算法本质上是问“鼠标正在触摸哪个 box”
3. 该算法返回链接到我们的 “SHARE IT” 按钮。
4. 浏览器会问这个问题:“既然有鼠标在你上方盘旋，我应该做什么?”。
5. 它快速运行此框及其子框的样式/级联，并确定`:hover` 在声明块内部有一个仅使用绘制样式调整的伪类。
6. 它将这些样式挂起 DOM 元素（正如我们在级联阶段所学到的），在这种情况下是按钮。
7. 它跳过布局，直接绘制一个新的位图。
8. 新的位图被传递给合成程序，然后传递给用户。

## JavaScript 解释器

------

#### 一些名词

**JS引擎** — 一个读取代码并运行的引擎，没有单一的“JS引擎”;每个浏览器都有自己的引擎，如谷歌有V8。

**作用域** — 可以从中访问变量的“区域”。

**词法作用域**— 在词法阶段的作用域,换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。

**块作用域** — 由花括号{}创建的范围

**作用域链** — 函数可以上升到它的外部环境(词法上)来搜索一个变量，它可以一直向上查找，直到它到达全局作用域。

**同步** — 一次执行一件事， “同步”引擎一次只执行一行，JavaScript是同步的。

**异步** — 同时做多个事，JS通过**浏览器API**模拟异步行为

**事件循环(Event Loop)** - 浏览器API完成函数调用的过程，将回调函数推送到回调队列(callback queue)，然后当堆栈为空时，它将回调函数推送到调用堆栈。

**堆栈** —一种数据结构，只能将元素推入并弹出顶部元素。 想想堆叠一个字形的塔楼; 你不能删除中间块，后进先出。

**堆** — 变量存储在内存中。

**调用堆栈** — 函数调用的队列，它实现了堆栈数据类型，这意味着一次可以运行一个函数。 调用函数将其推入堆栈并从函数返回将其弹出堆栈。

**执行上下文** — 当函数放入到调用堆栈时由JS创建的环境。

**闭包** — 当在另一个函数内创建一个函数时，它“记住”它在以后调用时创建的环境。

**垃圾收集** — 当内存中的变量被自动删除时，因为它不再使用，引擎要处理掉它。

**变量的提升**— 当变量内存没有赋值时会被提升到全局的顶部并设置为`undefined`。

**this** —由JavaScript为每个新的执行上下文自动创建的变量/关键字。



### 调用堆栈(Call Stack)

------

看看下面的代码：

```javascript
var myOtherVar = 10

function a() {
  console.log('myVar', myVar)
  b()
}

function b() {
  console.log('myOtherVar', myOtherVar)
  c()
}

function c() {
  console.log('Hello world!')
}

a()

var myVar = 5
```

以下是打印结果：

```javascript
"myVar" undefined
"myOtherVar" 10
"Hello world!"
```

来分解一下上述的执行步骤。

#### **1. 变量和函数声明(创建阶段)**

第一步是在内存中为所有变量和函数分配空间。 但请注意，除了`undefined`之外，尚未为变量分配值。 因此，`myVar`在被打印时的值是`undefined`，因为JS引擎从顶部开始逐行执行代码。

函数与变量不一样，函数可以一次声明和初始化，这意味着它们可以在任何地方被调用。

所以以上代码看起来像这样子：

```javascript
var myOtherVar = undefined
var myVar = undefined

function a() {...}
function b() {...}
function c() {...}
```

这些都存在于JS创建的全局上下文中，因为它位于全局空间中。

在全局上下文中，JS还添加了：

1. 全局对象(浏览器中是 `window` 对象，NodeJs 中是 `global` 对象)
2. this 指向全局对象

#### 2. 执行

接下来，JS 引擎会逐行执行代码。

```javascript
myOtherVar = 10`在全局上下文中，`myOtherVar`被赋值为`10
```

已经创建了所有函数，下一步是执行函数 `a()`

每次调用函数时，都会为该函数创建一个新的上下文(重复步骤1)，并将其放入调用堆栈。

```javascript
function a() {
  console.log('myVar', myVar)
  b()
}
```

如下步骤：

1. 创建新的函数上下文
2. `a` 函数里面没有声明变量和函数
3. 函数内部创建了 `this` 并指向全局对象(window)
4. 接着引用了外部变量 `myVar`，`myVar` 属于全局作用域的。
5. 接着调用函数 `b` ，函数`b`的过程跟 `a`一样，这里不做分析。

下面调用堆栈的执行示意图：

![](D:\前端笔记\浏览器机制\image\3331389215-5d09102b5c20f_articlex (2).gif)

1. 创建全局上下文，全局变量和函数。
2. 每个函数的调用，会创建一个上下文,外部环境的引用及 `this`。
3. 函数执行结束后会从堆栈中弹出，并且它的执行上下文被垃圾收集回收(闭包除外)。
4. 当调用堆栈为空时，它将从事件队列中获取事件。

### 作用域及作用域链

------

在前面的示例中，所有内容都是全局作用域的，这意味着我们可以从代码中的任何位置访问它。 现在，介绍下私有作用域以及如何定义作用域。

#### 函数/词法作用域

考虑如下代码：

```javascript
function a() {
  var myOtherVar = 'inside A'

  b()
}

function b() {
  var myVar = 'inside B'

  console.log('myOtherVar:', myOtherVar)

  function c() {
    console.log('myVar:', myVar)
  }

  c()
}

var myOtherVar = 'global otherVar'
var myVar = 'global myVar'
a()
```

需要注意以下几点：

1. 全局作用域和函数内部都声明了变量
2. 函数`c`现在在函数`b`中声明

打印结果如下：

```javascript
myOtherVar: "global otherVar"
myVar: "inside B"
```

执行步骤：

1. 全局创建和声明 - 创建内存中的所有函数和变量以及全局对象和 `this`
2. 执行 - 它逐行读取代码，给变量赋值，并执行**函数a**
3. **函数a**创建一个新的上下文并被放入堆栈，在上下文中创建变量`myOtherVar`，然后调用**函数b**
4. **函数b** 也会创建一个新的上下文，同样也被放入堆栈中

5，**函数**b的上下文中创建了 `myVar` 变量，并声明**函数c**

上面提到每个新上下文会创建的外部引用，外部引用取决于函数在代码中声明的位置。

1. **函数b**试图打印`myOtherVar`，但这个变量并不存在于**函数b**中，函数b 就会**使用它的外部引用上作用域链向上找**。由于**函数b**是全局声明的，而不是在**函数a**内部声明的，所以它使用全局**变量myOtherVar**。
2. **函数c**执行步骤一样。由于**函数c**本身没有变量`myVar`，所以它它通过作用域链向上找，也就是**函数b**，因为`myVar`是**函数b**内部声明过。

下面是执行示意图：

![](D:\前端笔记\浏览器机制\image\scope.png)

请记住，外部引用是单向的，它不是双向关系。例如，**函数b**不能直接跳到**函数c**的上下文中并从那里获取变量。

最好将它看作一个只能在一个方向上运行的链(范围链)。

- a -> global
- c -> b -> global

在上面的图中，你可能注意到，函数是创建新作用域的一种方式。(除了全局作用域)然而，还有另一种方法可以创建新的作用域，就是**块作用域**。

#### 块作用域

下面代码中，我们有两个变量和两个循环，在循环重新声明相同的变量，会打印什么(反正我是做错了)？

```javascript
function loopScope () {
  var i = 50
  var j = 99

  for (var i = 0; i < 10; i++) {}

  console.log('i =', i)

  for (let j = 0; j < 10; j++) {}

  console.log('j =', j)
}

loopScope()
```

打印结果：

```javascript
i = 10
j = 99
```

第一个循环覆盖了`var i`，对于不知情的开发人员来说，这可能会导致bug。

第二个循环,每次迭代创建了自己作用域和变量。 这是因为它使用`let`关键字，它与`var`相同，只是`let`有自己的块作用域。 另一个关键字是`const`，它与`let`相同，但`const`常量且无法更改(指内存地址)。

**块作用域由大括号 {} 创建的作用域**

再看一个例子：

```javascript
function blockScope () {
  let a = 5
  {
    const blockedVar = 'blocked'
    var b = 11

    a = 9000
  }

  console.log('a =', a)
  console.log('b =', b)
  console.log('blockedVar =', blockedVar)
}

blockScope()
```

打印结果：

```javascript
a = 9000
b = 11
ReferenceError: blockedVar is not defined
```

1. `a`是块作用域，但它在函数中，而不是嵌套的，本例中使用`var`是一样的。
2. 对于块作用域的变量，它的行为类似于函数，注意`var b`可以在外部访问，但是`const blockedVar`不能。
3. 在块内部，从作用域链向上找到 `a` 并将`let a`更改为`9000`。

使用块作用域可以使代码更清晰，更安全，应该尽可能地使用它。

## 事件循环(Event Loop)

------

接下来看看**事件循环**。 这是回调，事件和浏览器API工作的地方

![](D:\前端笔记\浏览器机制\image\loop.png)

我们没有过多讨论的事情是**堆**，也叫**全局内存**。它是变量存储的地方。由于了解JS引擎是如何实现其数据存储的实际用途并不多，所以我们不在这里讨论它。

来个异步代码：

```javascript
function logMessage2 () {
    console.log('Message 2')
}

console.log('Message 1')

setTimeout(logMessage2, 1000)

console.log('Message 3')
```

上述代码主要是将一些 message 打印到控制台。 利用`setTimeout`函数来延迟一条消息。 我们知道js是同步，来看看输出结果

```javascript
Message 1
Message 3
Message 2
```

1. 打印 Message 1
2. 调用 setTimeout
3. 打印 Message 3
4. 打印 Message 2

它记录消息3

稍后，它会记录消息2

`setTimeout`是一个 API，和大多数浏览器 API一样，当它被调用时，它会向浏览器发送一些数据和回调。我们这边是延迟一秒打印 **Message 2**。

调用完`setTimeout` 后，我们的代码继续运行，没有暂停，打印 **Message 3** 并执行一些必须先执行的操作。

浏览器等待一秒钟，它就会将数据传递给我们的回调函数并将其添加到事件/回调队列中( event/callback queue)。 然后停留在队列中，只有当**调用堆栈(call stack)**为空时才会被压入堆栈。

![](D:\前端笔记\浏览器机制\image\707449458-5d09cdca88cef_articlex.gif)

# ref 

[前端文摘：深入解析浏览器的幕后工作原理](https://www.cnblogs.com/lhb25/p/how-browsers-work.html)

[浏览器解析 CSS 样式的过程](https://segmentfault.com/a/1190000018717319)

 [搞懂JavaScript引擎运行原理](https://segmentfault.com/a/1190000019530109)





















